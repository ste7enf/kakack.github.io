<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>Kaka Chen</title>
    <link href="http://kakack.github.io/feed/" rel="self" />
    <link href="http://ellochen.github.com" />
    <lastBuildDate>2014-03-13T01:33:50+08:00</lastBuildDate>
    <webMaster>silver.accc@gmail.com</webMaster>
    
    <item>
      <title>浅谈推荐系统</title>
      <link href="http://kakack.github.io/2014/03/%E6%B5%85%E8%B0%88%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
      <pubDate>2014-03-11T00:00:00+08:00</pubDate>
      <author>Kaka Chen</author>
      <guid>http://kakack.github.io/2014/03/浅谈推荐系统</guid>
      <content:encoded><![CDATA[<p><img src="http://www.asqql.com/upfile/2009pasdfasdfic2009s305985-ts/2010-9/20109259215314784_asqql.com.gif" alt="" />
<del>实习君，能不能快点收了我</del></p>

<p>前言，之前看了<a href="http://blog.csdn.net/v_july_v/article/details/7184318">july君的推荐引擎算法学习导论</a>与本科室友<a href="http://www.cnblogs.com/flclain/archive/2013/03/03/2941397.html#2626700">懒惰啊我君在博客园的文章自己动手写推荐系统</a>后，也读了一部分有关推荐系统的资料和书籍，仅以此博文当做自己对这段时间学习的记录和温习，如有写的不妥之处欢迎批评纠正。因为自己也刚刚是个半吊子的学生，所以只能先梳理一些浅显易懂的内容，具体的实践和推导之后再写。</p>

<hr />

<h2>Reading Recommend</h2>

<ul>
<li><a href="http://book.douban.com/subject/3695850/">Recommender Systems Handbook</a>：水平较高，专题性较强，可惜只找到英文版，建议有一定基础后再啃。<del>博主暂时还只能处于看Contents的阶段</del></li>
<li><a href="http://book.douban.com/subject/3288908/">集体智慧编程</a>：讲究挖掘和分析web上的数据，Python讲解，入门宝典1.0，适合博主这样的菜比</li>
<li><a href="http://book.douban.com/subject/10769749/">推荐系统实践</a>：最大优点就是短小精悍，比集体智慧编程更进一步，小白最爱2.0</li>
<li><a href="http://book.douban.com/subject/25837140/">Mahout实战</a>：偏重实践，使用mahout框架，难度较之前基本要大</li>
</ul>


<hr />

<h2>Brief Content</h2>

<p>所谓推荐系统，从字面就能窥得一二，就是“用来做推荐的一组算法或者一个成型的系统”。为什么要推荐？我自己要喜欢什么自己还不知道吗？对，有时候还真不知道，尤其是在数据量巨大的情况下，在一些情况下，用户个人通过搜索引擎来精确定位某一个item或者subject已经是非常困难了，因为很多用户甚至都不知道那些符合自己要求或者兴趣的item的存在，这也是推荐系统（Recommender System，RS）存在的意义。</p>

<p><img src="http://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy1/image003.jpg" alt="" /></p>

<p>其中，现在常见的RS可以分成三类：</p>

<ul>
<li>基于人：根据不同类型的人群进行推荐，颗粒较粗。先将待推荐人的特征记录建模，与已有模型进行比较，选择现有的相似性大的个体感兴趣的item进行推荐。优点是不需要历史数据，没有冷启动问题，同时也不依赖于物品属性。缺点是算法比较粗暴，真实的应用效果一般。</li>
</ul>


<p><img src="http://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy1/image005.jpg" alt="" /></p>

<ul>
<li><p>基于资源：这次把建模的重点放在item上，大致与第一个相同，选择一个或几个相似度高的item，然后推荐给对那些item感兴趣的人。这个就需要有item的历史记录，有冷启动问题，而且物品属性很难全部罗列，比较片面。但是可以更好地对用户兴趣建模，精度可以提高。
<img src="http://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy1/image007.jpg" alt="" /></p></li>
<li><p>协同过滤（Collaborative Filtering, CF）：这个是现在用的最多的一类，也是技术要求最高，最值得研究的一类。这一类中还能细分为基于用户的CF，基于项目的CF和基于模型的CF三种，更偏重于细颗粒的特征。</p></li>
</ul>


<hr />

<h2>Collaborative Filtering</h2>

<p>概括言之，协同过滤是对一大群人和一大堆待推荐的item进行搜索，将人分成品味相近的若干组，将item分为特征相似的若干组，再将这些组相互组合和排名，行成一份item-to-people的推荐表。整个过程分为<strong><em>数据搜集，相似用户和item分类，进行推荐</em></strong>的三步走。</p>

<ol>
<li>数据搜集：一般有两种手段，可以是在线读取，如某个用户做了一个对某项item感兴趣的操作，推荐系统就记录一下，还有一种是将大量log文件存在db上，定期读取。读取之后最好还会做一个过滤清洗操作，把一些操作数低于阀值的用户和item的记录去除，或者可以添加一个black/white-list，自定义对一些恶意操作或者无意义操作进行清洗。</li>
<li>相似用户和item分类：最简单而常用的相似度的计算一般有两种，欧几里得距离和皮尔逊相关度。另外还有Cosine相似度和Tanimoto系数等。

<ul>
<li>欧式距离：即常见的二维空间两点距离，相似度取其与1的和的倒数，所以其取值范围为0到1，离的越近就认为二者越相似，一般如果有多个共同标记内容，就把这些item的欧式距离求和再去做倒数，但是我在读到这种做法有个问题，就是如果我们不管阀值的情况下有A，B，C三个人，A只对前三个item评分，分别为{2,6,5}，B对前五个item评分，分别为{3,7,7,4,5}，C也对前五个item评分，为{2,6,5,4,4}，如果用简单的欧式距离计算，得到A和B的相似度是1/(1+sqrt(pow(2-3)+pow(6-7)+pow(5-7)))=0.33333，而B和C的相似度是1/(1+sqrt(pow(3-2)+pow(7-6)+pow(7-5)+pow(4-4)+pow(5-4)))=0.3090，不如A与B，但是如果把图像画出来会发现，直观上还是C与B之间的曲线相似度更高，如果之后B和C有更多拟合程度很高的评分出现，这种现象还会更明显，所以欧式计算法对于评分item数量不同的若干人之间的比较效果不好，我不知道有没有深入的解决这问题的办法，回头问一下懒惰啊我。</li>
</ul>


<p> <img src="http://hi.csdn.net/attachment/201201/8/0_13260021604dW2.gif" alt="" /><img src="http://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy2/image005.gif" alt="" /></p>

<ul>
<li>皮尔逊相关度：可能就是从这个角度想到，皮尔逊相关度就是从曲线拟合度下手，虽然比欧式距离复杂，但是效果好很多。一般会找到两位评论者共同评价过的物品，然后计算两者评分总和和平方和以及评分的乘积之和，最后求得皮尔逊相关系数。计算方法类似方差计算。返回值的在-1和1之间，其中1则表示对每样物品都有完全一样的评价</li>
</ul>


<p> <img src="http://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy2/image007.gif" alt="" />，</p>

<ul>
<li>余弦相似度Cosine-based Similarity：将两人对某一组共n个item的评分看做一个n维的向量，向量的内积余弦值即为相似度。
<img src="http://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy2/image009.gif" alt="" /></li>
<li>Tanimoto 系数：类似内积计算的另一种办法。
<img src="http://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy2/image011.gif" alt="" /></li>
</ul>
</li>
<li>进行推荐：在计算完相似度之后，就可以进行推荐操作了，其中又可以以用户或者item分别作为推荐的主要依据。前者是基于用户根据不同item的评分，找到相邻的k个用户，预测当前用户没有的item进行推荐。</li>
</ol>


<p><img src="http://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy2/image015.gif" alt="" /></p>

<p>后者是找到相似度最近的k个物品，根据用户的历史偏好，预测当前用户还没有偏好的item进行推荐。</p>

<p><img src="http://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy2/image017.gif" alt="" /></p>

<hr />

<h2>Data Clustering</h2>

<p>聚类是一种典型的无监督学习方法，没有标准答案，计算目的是将一个巨大冗杂的数据集分割成若干个簇cluster，其中同一个簇内的元素相关程度高，不同簇之间的元素相关程度低。在《集体智慧编程》一书中，介绍的是用分级聚类来构建聚类的树状图，思路就是通过特征向量之间的距离为相似值依据，将最近的两个族群合并为一个新的族群并且以此类推，两两族群合并形成一个层次结构。</p>

<p>一般来说，提到聚类了就不能不提K-means算法了，其思路即在于找到某一个自然聚类的中心，将各个群组之间的均方误差降到最小。大致步骤如下：
<img src="http://hi.csdn.net/attachment/201201/9/0_1326105670fZz3.gif" alt="" />
  1. 如果我们要把整个数据集分成两个cluster，那么先随机的选择两个点，作为中心位置；
  2. 将数据集中所有的点都依次分配给距离较近的那个“中心点”，得到两个簇；
  3. 根据现有的分布情况，重新计算每个簇的中心位置；
  3. 然后根据新得到的中心点，把1~3步骤再过一遍，直到得到得到结果与上一次相同或者低于某一个阀值</p>

<p> 除了K-means外，Canopy聚类算法也很常见，的基本原则是：首先应用成本低的近似的距离计算方法高效的将数据分为多个组，这里称为一个Canopy，我们姑且将它翻译为“华盖”，Canopy 之间可以有重叠的部分；然后采用严格的距离计算方式准确的计算在同一Canopy中的点，将他们分配与最合适的簇中。Canopy 聚类算法经常用于 K 均值聚类算法的预处理，用来找合适的k值和簇中心。</p>

<hr />

<h2>Classification</h2>

<p>分类在此的作用就在于要把新获得的item归类到哪一个已有类别的item中，常用的办法是决策树Decision Tree。</p>

<p>其中决策树更像是一个游戏地图，到了某个npc（树节点）处可以和他对话，你的不同的选择会决定你接下去会遇到哪个npc。所以说不同于贝叶斯算法，决策树的构造过程不依赖领域知识，它使用属性选择度量来选择将元组最好地划分成不同的类的属性。所谓决策树的构造就是进行属性选择度量确定各个特征属性之间的拓扑结构。 构造决策树的关键步骤是分裂属性。所谓分裂属性就是在某个节点处按照某一特征属性的不同划分构造不同的分支，其目标是让各个分裂子集尽可能地“纯”。尽可能“纯”就是尽量让一个分裂子集中待分类项属于同一类别。分裂属性分为三种不同的情况：</p>

<pre><code>  1、属性是离散值且不要求生成二叉决策树。此时用属性的每一个划分作为一个分支。

  2、属性是离散值且要求生成二叉决策树。此时使用属性划分的一个子集进行测试，按照“属于此子集”和“不属于此子集”分成两个分支。

  3、属性是连续值。此时确定一个值作为分裂点split_point，按照&gt;split_point和&lt;=split_point生成两个分支。
</code></pre>

<p>构造决策树的关键性内容是进行属性选择度量，属性选择度量是一种选择分裂准则，是将给定的类标记的训练集合的数据划分D“最好”地分成个体类的启发式方法，它决定了拓扑结构及分裂点split_point的选择。属性选择度量算法有很多，一般使用自顶向下递归分治法，并采用不回溯的贪心策略。常用的建树方法比如ID3，之后祥讲，在此不涉及了。由于决策树的白箱规则，所以可以清晰地看到每个流程的行为，其又是非参数的，可以应付任何连续和类别变量，所以真正使用的时候，很多人都把决策树当做最好的分类算法。</p>

<hr />

<h2>Else Stuff</h2>

<p>其实除了上述一些内容外，一个合格的推荐系统还有很多组成部分，比如要对结果做优化，对item可以做搜索，还可以做一些规则的增加比如广告插入，anti-Spam等，因为博主晚上写这篇博客的时候接到了一个公司电面，结果被吐槽了一通，于是只能继续灰溜溜看Java基础去了，其余的内容之后有空了慢慢补充。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Java编程思想学习小记</title>
      <link href="http://kakack.github.io/2014/03/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/"/>
      <pubDate>2014-03-08T00:00:00+08:00</pubDate>
      <author>Kaka Chen</author>
      <guid>http://kakack.github.io/2014/03/JAVA编程思想学习小记</guid>
      <content:encoded><![CDATA[<p><img src="http://img3.yytcdn.com/uploads/attachments/fan_topic_reply/6593671/F5CE01342B76A652CF0557DB6952C848.gif" alt="" />
<del>经过这几次面试被吐槽，突然发现会用java和懂java真是两种不一样的境界啊！</del></p>

<p>推荐一个博客园里我觉得写java写的最好的博客<a href="http://www.cnblogs.com/skywang12345/">戳</a>，自带源码，看起来爽爆！</p>

<hr />

<h2>概况</h2>

<p>Java和Javax都是Java的API包，其中Javax的x是extension扩展的意思，其中核心包13个</p>

<ul>
<li>java.applet：提供创建 applet 所必需的类和 applet 用来与其 applet 上下文通信的类。Applet是一种在web环境下，于浏览器或者客户端运行的java程序组件</li>
<li>java.awt：包含用于创建用户界面和绘制图形图像的所有类。</li>
<li>java.beans：JavaBean是一种特殊的java类，是一种可以重复使用的软件组件，优点是可序列化，提供无参构造器，提供getter和setter方法访问对象属性。</li>
<li>java.io：通过数据流、序列化和文件系统提供系统输入和输出。</li>
<li>java.lang：提供利用 Java 编程语言进行程序设计的基础类。</li>
<li>java.math：提供用于执行任意精度整数算法 (BigInteger) 和任意精度小数算法 (BigDecimal) 的类。</li>
<li>java.net：为实现网络应用程序提供类。</li>
<li>java.nio：定义作为数据容器的缓冲区，并提供其他 NIO 包的概述。</li>
<li>java.rmi：提供RMI包</li>
<li>java.security：为安全框架提供类和接口。</li>
<li>java.sql：提供使用 JavaTM 编程语言访问并处理存储在数据源（通常是一个关系数据库）中的数据的 API。</li>
<li>java.text：提供以与自然语言无关的方式来处理文本、日期、数字和消息的类和接口。</li>
<li>java.util：包含 collection 框架、遗留的 collection 类、事件模型、日期和时间设施、国际化和各种实用工具类（字符串标记生成器、随机数生成器和位数组）。</li>
</ul>


<hr />

<h2>语句结构</h2>

<p>Java跳出循环结构的办法：Java中的break和continue都只能作用于最内层的循环，如果要在内层跳出外层循环，可以有这么两种办法</p>

<ul>
<li>可以在外循环中定义一个标号，然后在里层循环体中break后加上这个标号：</li>
</ul>


<pre><code>ok:
for(int i=0;i&lt;10;i++) {   

   for(int j=0;j&lt;10;j++) {   
     System.out.println(“i=” + i + “,j=” + j);
     if(j == 5) break ok;
  }

}
</code></pre>

<ul>
<li> 或者在里层循环体中可以控制外层循环结构的控制变量：</li>
</ul>


<pre><code>int arr[][] ={   {1,2,3},{4,5,6,7},{9}    };
boolean found = false;
for(int i=0;i&lt;arr.length&amp;&amp; !found;i++){
   for(int j=0;j&lt;arr[i].length;j++){
      System.out.println(“i=” + i + “,j=” + j);
      if(arr[i][j]  ==5) {
        found = true;
        break;
    }
  }
}
</code></pre>

<p>Switch(exp)语句中对exp的要求：exp只能是一个整数表达或者一个枚举常量，整数表达式可以是int基本类型或Integer包装类型，由于byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。而long、String则不可以，不过现在在Java7中，String也被允许。</p>

<p>比较“==”操作符与equals操作符比较：对于Java中已有的类，==操作符判断的是某一个变量值是否一样，如果是对象的比较，则会比较所引用的对象是否一样；而equals比较的是两个对象内容是否一样，不需要引用同一个对象，但是如果是自己定义的对象，equals要重写，如果使用默认的Object类的equals方法，就等于==操作符。附上Object类的equals方法：</p>

<pre><code>boolean equals(Object o){
return this==o;
}
</code></pre>

<p>Override和Overload：Override是重写，Overload是重载。重载Overload表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。重写Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法。其中，父类的Constructor不能被继承，因此也不能被重写Override，但是可以被重载Overload，如果自己没有写Constrictor，那么系统会自己生成一个默认无参构造器，但如果已经自己写了构造器，就不能使用默认构造器了。</p>

<ul>
<li><p>Override：</p>

<ol>
<li>覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；</li>
<li>覆盖的方法的返回值必须和被覆盖的方法的返回一致；</li>
<li>覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；</li>
<li>被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</li>
</ol>
</li>
<li>Overload:

<ol>
<li>在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int,float)，但是不能为fun(int,int)）；</li>
<li>不能通过访问权限、返回类型、抛出的异常进行重载；</li>
<li>方法的异常类型和数目不会对重载造成影响；</li>
<li>对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。</li>
</ol>
</li>
</ul>


<p>关于try-catch-finally语句的执行：先执行try中的语句，如果有异常，在相应的catch中执行，然后再执行finally中的语句，如果在catch中有return语句，那么，在这个return这个地方，程序先暂停一下，把现有的变量保存压到堆中，去执行finally 里面的东西，执行完毕了，再把堆中保存的变量拿出来来执行return语句的。可以看下面一个例子，结果是：</p>

<pre><code>在finally里面的x：2

1
</code></pre>

<p>代码如下：</p>

<pre><code>    public static void main(String[] args) {
        System.out.println(new Test().test());
    }
    static int test() {
        int x = 1;
        try {
            return x;   //值为1的x被保存起来
        } finally {
            x = 2;
            System.out.println("在finally里面的x：" + x);//先执行了这个，打印出了x为2
        }
    }
</code></pre>

<hr />

<h2>对象相关</h2>

<ol>
<li><p>面向对象的编程有以下四个特点：</p>

<ul>
<li>封装：保证程序模块最优性，实现“高内聚，低耦合”，将对象封装成高度自治和封闭的个体，减少模块与对象之间的依赖关系。</li>
<li>抽象：抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。</li>
<li>继承：实现类的扩充和多样化应用，可以新增或者修改原有类的成员来更好地应用于现有的情况，提高程序的可重用性和扩展性。</li>
<li>多态：实现程序调用时才决定其引用的参数或使用的方法的具体类型</li>
</ul>
</li>
<li><p>操纵对象的标示符其实是一个引用reference</p></li>
<li><p>对象的创建可以在堆栈中或者堆中。前者将储存空间分配和释放处于优先位置，后者动态创建，直到运行时才会直到其真正生命周期</p></li>
<li><p>对象的储存：有五种方法</p>

<ul>
<li>寄存器内部，最快，因为在处理器内部，但数量有限且不能直接控制</li>
<li>堆栈，位于RAM，创建初期直到对象在堆栈内生命周期，可以控制<em>堆栈指针</em>上下操作</li>
<li>堆，一种通用的内存池，位于RAM，用于存放所有Java对象，较为灵活</li>
<li>常量储存，常存在程序代码内部，安全，也可以在ROM中</li>
<li>非RAM储存，例如流对象和持久化对象</li>
</ul>
</li>
<li><p>三种类的复用关系：组合、继承extend和代理。其中组合是显式的，继承是隐式的，而代理处于两者之间。 子类到父类还能向上转型upcasting。</p></li>
<li>final关键字：其实是指一个值或者一个对象的引用不能被修改，但是可以通过修改被引用的对象中的内容

<ul>
<li>数据：一个不变的编译时常量；一个在运行时被初始化后就不会改变的值</li>
<li>方法：保证继承时候方法不会被修改，又保证效率</li>
<li>类：该类不能被继承</li>
</ul>
</li>
</ol>


<pre><code class="`">      final StringBuffer a=new StringBuffer("Hello!");
      StringBuffer b=new StringBuffer("World!");

//    a=new StringBuffer("yes!");     //这个编译错误，不允许修改引用
      a.append(b);                    //这个可以通过，将a中的值改为"Hello！World!"
</code></pre>

<p> Java基本类型列表：不用new来创建，是<strong><em>非引用</em></strong>的自动变量，这个变量直接储存值并且至于堆栈中。</p>

<table class="table table-bordered table-striped table-condensed">
    <tr>
        <td>基本类型</td>
        <td>大小 </td>
        <td>区间 </td>
        <td>包装器类型 </td>
    </tr>
    <tr>
        <td>boolean </td>
        <td>- </td>
        <td>- </td>
        <td>Boolean </td>
    </tr>
    <tr>
        <td>char </td>
        <td>16-bit</td>
        <td>Unicode 0 ~ Unicode 2^16 </td>
        <td>Character </td>
    </tr>
    <tr>
       <td>byte</td> 
       <td>8-bit</td>
       <td>-128 ~ 127</td>
       <td>Byte</td>
    </tr>
    <tr>
       <td>short</td>
       <td>16-bit</td>
       <td>-2^15 ~ 2^15 -1</td>
       <td>Short</td>
   </tr>
   <tr>
        <td>int</td>
        <td>32-bit</td>
        <td>-2^31 ~ 2^31 - 1</td>
        <td>Interger</td>
   </tr>
   <tr>
        <td>long</td>
        <td>64-bit</td>
        <td>-2^63 ~ 2^63 - 1</td>
        <td>Long</td>
   </tr>
   <tr>
        <td>float</td>
        <td>32-bit</td>
        <td>IEEE753 ~IEEE754</td>
        <td>Float</td>
   </tr>
   <tr>
        <td>double</td>
        <td>64-bit</td>
        <td>IEEE754 ~ IEE754</td>
        <td>Double</td>
   </tr>
   <tr>
       <td>void</td>
       <td>-</td>
       <td>-</td>
       <td>Void</td>
   </tr>
</table>


<p>其中boolean占多大空间没有明确定义，仅仅指定字面的true or false</p>

<p>Java中还有一类复杂数据类型，如Integer，是int的封装类，当做对象来处理，如放到一个ArrayList中，只能是Integer，Integer为int提供了与String相互传递的方法。此外，int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别</p>

<p>当Java中的方法参数是简单类型的时候，是通过值传递的方法，也就是该方法只复制了参数的值，在方法中对这个值的任何操作都不会影响原值。而方法对于参数对象的操作却是以引用参数的形式进行，没有将其实例化但是却借用了它的一个“别名”，传递的实际值是对象在内存中的地址，所以对其做操作会影响到内存中源对象参数的值。我写了个例子，重写了三个swap()函数，第一第三个实际是对对象进行操作，属于引用传递，第二个是值传递。</p>

<pre><code>public class Test {
    public static void main(String args[]){   
        Test sw = new Test(1,2);   
        System.out.println("i is" + sw.i);   
        System.out.println("j is" + sw.j);   

  //      sw.swap();             //直接改变当前对象内部参数      
  //      sw.swap(sw.i,sw.j);    //值传递，会不改变外部两个int的值 
          sw.swap(sw);           //使用引用传参的方法改变已经实例化对象内部参数

        System.out.println("i is" + sw.i);   
        System.out.println("j is" + sw.j);   
    }   
    int i,j;   
    public Test(int i, int j){   
        this.i = i;   
        this.j = j;   
    }   

    public  void swap(){   //通过对象内部成员参数变化
        int temp;   
        temp = i;   
        i = j;   
        j = temp;   
    }

    public void swap(int a,int b){    //只是参数传递值
        int tmp=a;
        a=b;
        b=tmp;
        System.out.println("a is" + a);   
        System.out.println("b is" + b); 
    }

    public void swap(Test in){
        int tmp=in.i;
        in.i=in.j;
        in.j=tmp;
    }
}
</code></pre>

<p>另外，如果将其中一个引用传给另一个，那么改变其中一个就会使这两个参数都改变，如</p>

<pre><code>Test ts=new Test();
        Test tb=new Test();
        ts.a=1;
        tb=ts;
        ts.a=2;     //不论真正执行的是这一句还是下面那句，输出结果都是两个2
//      tb.a=2;         
        System.out.println(ts.a);
        System.out.println(tb.a);
</code></pre>

<p>所以为了保证修改一个但是不影响另一个，在我们赋值的时候常用clone()方法。首先要实现Cloneable接口，然后在重载clone方法，最后在clone()方法中调用了super.clone()，这也意味着无论clone类的继承结构是什么样的，super.clone()直接或间接调用了java.lang.Object类的clone()方法。</p>

<pre><code>public class Test implements Cloneable {
    public String name;
    public Object clone() {
        Test o = null;
        try {
            o = (Test) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return o;
    }
}
</code></pre>

<p>这样当我们用clone()方法复制两个Test对象时，可以分别对其进行操作。</p>

<pre><code>        Test ts = new Test();
        ts.a = 1;
        Test tb =(Test)ts.clone();       //代替tb = ts;
        ts.a = 2;
        tb.a = 3;//可以肚子修改ts和tb
        System.out.println(ts.a);
        System.out.println(tb.a);
</code></pre>

<hr />

<h2>访问权限</h2>

<table border="1">
<tr>
    <td>作用域</td>
    <td>当前类</td>
    <td>同一package</td>
    <td>子孙类</td>
    <td>其他package</td>
</tr>
<tr>
    <td>public</td>
    <td>√</td>
    <td>√</td>
    <td>√</td>
    <td>√</td>
</tr>
<tr>
    <td>protected</td>
    <td>√</td>
    <td>√</td>
    <td>√</td>
    <td>&times;</td>
</tr>
<tr>
    <td>friendly</td>
    <td>√</td>
    <td>√</td>
    <td>&times;</td>
    <td>&times;</td>
</tr>
<tr>
    <td>private</td>
    <td>√</td>
    <td>&times;</td>
    <td>&times;</td>
    <td>&times;</td>
</tr>
</table>


<p>其中friendly又称为包访问权限。</p>

<hr />

<h2>抽象与接口</h2>

<p>抽象类abstract，包含一个或多个抽象方法，即仅有声明而没有方法体，如果子类没有实现抽象父类中所有的抽象方法，那么子类也必须定义为抽象类。而接口interface则提供一个完全抽象的类，其中所有方法都必须是抽象的。抽象类的作用是抽象出共同属性，所以可以有private等多种权限的成员变量和非抽象的成员方法，接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。抽象类是单一继承的，不能实例化。接口用于多重继承，也不能实例化。只能包含static final的成员变量，不过在interface中一般不定义成员变量。而成员方法在接口里只能是抽象方法，访问权限只能是public。</p>

<p>二者在语法上的区别</p>

<ol>
<li>抽象类可以有构造方法，接口中不能有构造方法。</li>
<li>抽象类中可以有普通成员变量，接口中没有普通成员变量</li>
<li>抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。</li>
<li>抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然
eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。</li>
<li>抽象类中可以包含静态方法，接口中不能包含静态方法</li>
<li>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。</li>
<li>一个类可以实现多个接口，但只能继承一个抽象类。</li>
</ol>


<p>二者在使用中，接口更多是在系统架构设计时发挥作用，是模块之间通信的契约，而抽象类更强调方便代码实现重用。</p>

<hr />

<h2>内部类</h2>

<p>定义在一个类内部的类叫内部类，包含内部类的类称为外部类。内部类可以声明public、protected、private等访问限制，可以声明为abstract的供其他内部类或外部类继承与扩展，或者声明为static、final的，也可以实现特定的接口。但是内部类中不能有任何static的成员。</p>

<p>外部类可以按照常规访问办法访问内部类中的所有成员，包括private成员。其他类可以访问内部类，可以使用外部类提供创建内部类的方法供其他类使用，或者直接创建内部类的对象。如果不需要借助外部类来访问，可以使用嵌套类，即加static。<strong>静态内部类</strong>可以不需要其他外部对象，不能从嵌套类的对象中访问非静态的外围类对象。</p>

<p><strong>匿名内部类</strong>是一种为了简介代码编写的办法，只能在定义后使用一次，而且必须继承一个父类或者实现一个接口，最常用在多线程上，继承Thread类或者实现Runnable接口</p>

<hr />

<h2>持有对象与集合类</h2>

<ol>
<li>Collection，最基本的集合接口，都支持iterator()方法来遍历集合

<ul>
<li><p>List：是有序的collection，允许有相同的元素，</p>

<ul>
<li><p><a href="http://www.cnblogs.com/skywang12345/p/3308807.html">LinkedList</a>：基于双向链表，特性集更大，但是开销更大，随机访问较慢。实现了List接口，允许null元素。此外LinkedList提供额外的get，remove，insert方法在LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。可以直接当做栈来使用</p></li>
<li><p><a href="http://www.cnblogs.com/skywang12345/p/3308556.html">ArrayList</a>：擅长随机访问元素，是有序的，实现了可变大小的数组，基于<strong>动态数组</strong>。当容量不足时，新的容量=“(原始容量x3)/2 + 1。</p></li>
<li><p><a href="http://www.cnblogs.com/skywang12345/p/3308833.html">Vector</a>：类似ArrayList，但是是可同步的，是可以clone的，容量不足事，新容量增长一倍。</p></li>
<li><p><a href="http://www.cnblogs.com/skywang12345/p/3308852.html">Stack</a>：继承自Vector实现一个后进先出的堆栈，也是数组实现</p></li>
</ul>
</li>
<li>Set

<ul>
<li><p><a href="http://www.cnblogs.com/skywang12345/p/3311252.html">HashSet</a>：最快的获取元素方式，同步访问，底层使用hashmap来保存元素，元素是无序的</p></li>
<li><p><a href="http://www.cnblogs.com/skywang12345/p/3311268.html">TreeSet</a>：按比较顺序的升序保存对象，使用TreeMap实现，元素是有序的</p></li>
<li><p>LinkedHashSet：按被添加的顺序保存对象</p></li>
</ul>
</li>
</ul>
</li>
<li>Map：一种以key-value的形式保存

<ul>
<li><p><a href="http://www.cnblogs.com/skywang12345/p/3310887.html">HashTable</a>：最基本的key-value映射的hash表，是同步的(通过synchronized方法实现)，是cloneable的，任何非空（non-null）的值都可以作为key或者value，默认的“加载因子”是0.75, 默认的容量大小是11， “实际容量” >= “阈值”时，(阈值 = 总的容量 x 加载因子)，就将变为“原始容量x2 + 1”。支持Iterator(迭代器)和Enumeration(枚举器)两种方式遍历。底层是用Entry[]数组储存键值对，继承自dictionary类。</p></li>
<li><p><a href="http://www.cnblogs.com/skywang12345/p/3310835.html">HashMap</a>：类似HashTable，是非同步的，允许null值，默认的“加载因子”是0.75, 默认的容量大小是16，“实际容量” >= “阈值”时，(阈值 = 总的容量 * 加载因子)，就将HashMap的容量翻倍。只支持迭代器遍历。</p></li>
<li><p><a href="http://www.cnblogs.com/skywang12345/p/3310928.html">TreeMap</a>：是一个有序的key-value集合，它是通过红黑树实现的,该映射根据其键的自然顺序进行排序，是非同步的。</p></li>
<li><p>WeakHashMap：改进的HashMap，实现弱引用，如果一个key不被外部引用则会被收回。</p></li>
</ul>
</li>
</ol>


<hr />

<h2>异常和错误</h2>

<p>异常Exception：Java传递给用户系统或者程序错误的方式。其中有检查异常和非检查异常，前者继承自java.lang.Exception类，需要try, catch和finally关键字在编译期进行处理，否则编译器会报错，而后者不需要这么做，继承自RuntimeException。</p>

<p>错误和异常的三个级别：1，Error表示应用程序本身无法克服和恢复的一种严重问题，程序只有死的份了，如内存溢出和死锁；2，Exception表示程序还能够克服和恢复的问题，其中又分为系统异常和普通异常，系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件死掉，例如，数组脚本越界（ArrayIndexOutOfBoundsException），空指针异常（NullPointerException）、类转换异常（ClassCastException）；3，普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉。</p>

<p>异常处理
-  调用方法的时候返回布尔值来代替返回null
-  catch块里打印异常信息
-  尽量抛出受控异常
-  防止数据库异常显示到客户端
-  要在数据库连接，数据库查询，流处理后，在finally块中调用close()方法</p>

<p>Throws和Throw的区别：throws总是出现在一个函数头中，用来标明该成员函数可能抛出的各种异常，是语句抛出异常，可以单独使用；throw用来让一个方法抛出任何异常，要和try-catch-finally一起使用，</p>

<p>final,finalize,finally关键字的区别：final关键字在创建不可变的类的时候非常有用，只是声明这个类是final的。而finalize()方法则是垃圾回收器在回收一个对象前调用。finally在你的产品代码中，在关闭连接和资源文件的是时候都必须要用到finally块。</p>

<hr />

<h2>IO</h2>

<p>Java的io由java.io库提供全面的io接口，基于流来操作，而nio中是基于块来操作。整个io体系被分为input/output和reader/writer两类。所谓的流Stream，是指有序的字节或者字符通过一个通信信道从源地址传送到目的地址。Java支持两个数据流：InputStream和OutputStream。其层次可分为：
1. File（文件特征与管理）：用于文件或者目录的描述信息，例如生成新目录，修改文件名，删除文件，判断文件所在路径等。
2. InputStream（二进制格式操作byte）：抽象类，基于字节的输入操作，是所有输入流的父类。定义了所有输入流都具有的共同特征。
3. OutputStream（二进制格式操作byte）：抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征。Java中字符是采用Unicode标准，一个字符是16位，即一个字符使用两个字节来表示。为此，JAVA中引入了处理字符的流。
4. Reader（文件格式操作）：抽象类，基于字符的输入操作。
5. Writer（文件格式操作）：抽象类，基于字符的输出操作。
6. RandomAccessFile（随机文件操作）：它的功能丰富，可以从文件的任意位置进行存取（输入输出）操作。</p>

<p>操作流程
在Java中IO操作也是有相应步骤的，以文件操作为例，主要的操作流程如下：</p>

<pre><code>  - 使用File类打开一个文件  
  - 通过字节流或字符流的子类，指定输出的位置
  - 进行读/写操作
  - 关闭输入/输出
</code></pre>

<p>字节流和字符流之间的区别：</p>

<pre><code>- 字节流在操作的时候本身是不会用到缓冲区（内存）的，是与文件本身直接操作的，而字符流在操作的时候是使用到缓冲区的
- 字节流在操作文件时，即使不关闭资源（close方法），文件也能输出，但是如果字符流不使用close方法的话，则不会输出任何内容，说明字符流用的是缓冲区，并且可以使用flush方法强制进行刷新缓冲区，这时才能在不close的情况下输出内容
</code></pre>

<p>NIO是jdk1.4中就有了的所谓的"新io"方式，可以认为是一种非阻塞的io，工作原理：</p>

<ol>
<li>由一个专门的线程来处理所有的 IO 事件，并负责分发。</li>
<li>事件驱动机制：事件到的时候触发，而不是同步的去监视事件。</li>
<li>线程通讯：线程之间通过 wait,notify 等方式通讯。保证每次上下文切换都是有意义的。减少无谓的线程切换。</li>
</ol>


<p>与传统io不同的是，nio用了一个双向通道Channel（包含socket，file和pipe三种管道）来代替原有的流stream，在channel上可以注册感兴趣的事件：服务端接收，客户端连接，读事件和写事件。用Selector管理channel，将多元异步操作集中到一个线程里。</p>

<p>Java序列化：Jre自带的将一个java对象变成字节流的形式传出去或者从一个字节流中恢复成一个java对象的功能，要被传输的对象必须实现serializable接口。</p>

<hr />

<h2>字符串String</h2>

<p>String对象是不可变的，每次看上去修改了一个String，实际上都是创建了一个新的String，因为它的<em>只读属性</em>，所以指向它的任何引用都不可能改变它的值。</p>

<p>计算一个string长度的方法是length()，感觉笔试题里很喜欢出这个。</p>

<p>还有一个比较喜欢出得String知识点是null和""之间的区别。
- 简单来说String s=null;只是定义了一个句柄，也就是说你有了个引用，但是这个引用未指乡任何内存空间   <br/>
- String s="";这个引用已经指向了一块是空字符串的内存空间，是一个实际的东东了，所以你可以对它操作，而不用担心什么了</p>

<pre><code>class Untitled {
    public static void main(String[] args) {
    String a="";
    String b="abc";
    String c=null;

    System.out.println(a); 
    System.out.println(a+b);
    System.out.println(c);
    System.out.println(c+b);
    }
}
</code></pre>

<p>输出分别是：</p>

<pre><code>abc
null
nullabc
</code></pre>

<p>另外一些像indexOf、replace、split等方法就不解释了，因为很多单单看方法名就能猜出是什么功能。</p>

<p>String和StringBuffer的比较：Java中对于字符和字符串的操作提供了三个类，分别是：1.Character 是进行单个字符操作的；2.String 对一串字符进行操作，不可变类；3.StringBuffer 也是对一串字符进行操作，但是可变类。所以对StringBuffer进行修改不会重新去建立一个新的对象，在初始化的时候定义好内容，然后用append方法进行增加。在String做增加操作的时候，实际上是先建立一个StringBuffer再作append然后再转为String。另外还有一种StringBuilder，是非线程安全的可变字符串，不保证同步。</p>

<hr />

<h2>线程与并发</h2>

<p>引入并发机制的主要目的是为了使我们可以将程序划分为多个分离的、独立运行的任务，其中每一个任务都由执行线程来驱动。继承Thread类、实现Runnable接口，在程序开发中只要是多线程，肯定永远以实现Runnable接口为主，因为实现Runnable接口相比继承Thread类有如下优势：</p>

<pre><code>1、可以避免由于Java的单继承特性而带来的局限；

2、增强程序的健壮性，代码能够被多个线程共享，代码与数据是独立的；

3、适合多个相同程序代码的线程区处理同一资源的情况。
</code></pre>

<p>在并发线程中，使用sleep()函数来实现线程的等待阻塞，让出cpu时间，但是它是Thread的static方法，所以线程虽然休眠了但是机锁没有释放，其他线程还是无法访问这个对象。而另一个外wait()方法则是将对象放入等待池并且释放机锁，可以用notify或者notifyAll来唤醒。</p>

<p>在并发多线程中，<strong><em>synchronized</em></strong>关键字很重要，是为了防止资源冲突提供的内置支持，当任务要执行被synchronized关键字保护的代码片段时，它将检查锁是否可用，然后获取锁，执行代码，释放锁。保证在执行synchronized(this)代码的时候，同一时刻最多只有一个线程执行，但是其他线程可以访问其他非synchronized(this)代码块，但是不能访问其他synchronized代码。Synchronized关键字可以形容一个方法或者一个代码块，如</p>

<ul>
<li>public synchronized void accessVal(int newVal);</li>
<li>synchronized(syncObject) {<br/>
//允许访问控制的代码<br/>
}</li>
</ul>


<p>在线程中start()方法是进入就绪状态，run()方法是启动线程。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Jvm性能优化</title>
      <link href="http://kakack.github.io/2014/03/JVM%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <pubDate>2014-03-07T00:00:00+08:00</pubDate>
      <author>Kaka Chen</author>
      <guid>http://kakack.github.io/2014/03/JVM性能优化</guid>
      <content:encoded><![CDATA[<p>这几天准备面试的时候看到一个讲JVM性能优化的系列博文，因为听说网易和阿里都喜欢问点java底层的问题，所以瞄了一下，感觉很有收获。</p>

<p>原文来自<a href="http://www.javaworld.com/article/2078623/core-java/jvm-performance-optimization--part-1--a-jvm-technology-primer.html">Java-world</a>，感谢博主<a href="http://www.importnew.com/author/caoxudong">曹旭东</a>的翻译。</p>

<ul>
<li><a href="http://www.importnew.com/1774.html">JVM性能优化， Part 1 ―― JVM简介 </a></li>
<li><a href="http://www.importnew.com/2009.html">JVM性能优化， Part 2 ―― 编译器 </a></li>
<li><a href="http://www.importnew.com/2233.html">JVM性能优化， Part 3 ―― 垃圾回收</a></li>
<li><a href="http://www.importnew.com/2410.html">JVM性能优化， Part 4 ―― C4 垃圾回收
</a></li>
<li><a href="http://www.importnew.com/6246.html">JVM性能优化， Part 5：Java的伸缩性
</a></li>
<li><a href="http://www.importnew.com/8631.html">在运行期通过反射了解JVM内部机制
</a></li>
</ul>

]]></content:encoded>
    </item>
    
    <item>
      <title>自己动手写chrome插件</title>
      <link href="http://kakack.github.io/2014/03/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99chrome%E6%8F%92%E4%BB%B6/"/>
      <pubDate>2014-03-02T00:00:00+08:00</pubDate>
      <author>Kaka Chen</author>
      <guid>http://kakack.github.io/2014/03/自己动手写chrome插件</guid>
      <content:encoded><![CDATA[<p><img src="http://p2.qqyou.com/biaoqing/uploadpic/2012-12/29/2012122921464172482.gif" alt="" /></p>

<p>昨晚一时脑抽，狠狠整理了一遍mac里的app，最后目光停留在了Chrome君身上，把很多以前瞎鸡巴下着后来自己用不着了的插件和应用都删了，又随手下了几个自己觉得比较牛逼的插件下来玩。<del>等一会儿要是我有dan空teng就写一篇推荐chrome插件的blog</del></p>

<p>之后我发现，体育栏目的插件质量显然太低了，连个能在线看NBA或者欧洲足球联赛及时比分的都没有，绝大多数都是以RSS新闻为主的形式，于是我决定第二天自己写一个能看NBA比分的那种插件。</p>

<hr />

<p>于是不做死就不会死……老子一天面试题没看……明天再这样我就切腹自尽！</p>

<hr />

<p>但是我从没chrome插件的经验，学的一点Java Script和HTML、CSS知识感觉也已经丢给<a href="http://www.w3school.com.cn/">W3C</a>了，于是我就这么开工了，话说兴趣与需求是第一生产力真没错，在此我简单介绍一下一个优lan秀wei的chrome插件的制作方法（此处应该有掌声）。</p>

<p>查资料发现，大流氓360做的唯一一件好事就是翻译了Google的<a href="http://open.chrome.360.cn/extension_dev/overview.html">Chrome开发文档</a>，给我着实省了不少事。广义上讲一个插件或者应用就是一组HTML，CSS，Javascript脚本，图片文件，还有其它任何需要的文件，以此来达到与浏览器或者web页面进行交互的目的。</p>

<hr />

<p>每个应用（扩展）都应该包含下面的文件：</p>

<ul>
<li><p>一个manifest文件</p></li>
<li><p>一个或多个html文件（除非这个应用是一个皮肤）</p></li>
<li><p>可选的一个或多个javascript文件</p></li>
<li><p>可选的任何需要的其他文件，例如图片</p></li>
</ul>


<p>在开发应用（扩展）时，需要把这些文件都放到同一个目录下。发布应用（扩展）时，这个目录全部打包到一个应用（扩展）名是.crx的压缩文件中。如果使用<a href="https://chrome.google.com/webstore/developer/dashboard">Chrome Developer Dashboard</a>,上传应用（扩展），可以自动生成.crx文件,但是要验证和正式发布插件要交$5的钱。黑啊，真黑啊！</p>

<hr />

<p>首先我在桌面上新建了一个文件夹，名字就是我这个插件的名字NBA-live-beta。然后用Sublime2在里面新建了一个manifest.json的文件，这个文件包含了应用（扩展）的基本信息，例如最重要的文件列表，应用（扩展）所需要的权限等。然后我参考着我本地一个插件的manifest的样子，写了如下代码。</p>

<pre><code>{
"name": "NBA Live beta",
"version": "0.1.0",
"description": "The first extension that I made.",
   "browser_action": {
      "default_icon": "icon.png",
      "default_popup": "popup.html"
   },
"manifest_version": 2,
"permissions": [
"http://api.flickr.com/"
]
}
</code></pre>

<p>我没有用全所有的标签，详情可以参考<a href="http://open.chrome.360.cn/extension_dev/manifest.html">Manifest file</a>。</p>

<p>在此只解释几个重要的，我写在这的标签。</p>

<ul>
<li>name：“插件名称”</li>
<li>version：“插件版本”</li>
<li>manifest version：2</li>
</ul>


<p>以上三个是必须填写的。</p>

<ul>
<li>description：描述，会显示在插件管理页面上</li>
<li>browser_action：浏览器行为，其中可以定义图标以及该插件的页面表型形式，有popup和background两种。区别如图：
<img src="http://img.qihoo.com/images/2008/360chrome/img/open/popup.gif" alt="" /></li>
</ul>


<p>popup是网页弹窗形式，background是后台运行计算形式。另外如果插件需要与web页面交互，那么就需要使用一个content script。Content script脚本是指能够在浏览器已经加载的页面内部运行的javascript脚本。可以将content script看作是网页的一部分，而不是它所在的应用（扩展）的一部分。</p>

<p><img src="http://img.qihoo.com/images/2008/360chrome/img/open/content.gif" alt="" /></p>

<p>Content script与它所在的应用（扩展）并不是完全没有联系。一个content script脚本可以与所在的应用（扩展）交换消息，如下图所示。例如，当一个content script从页面中发现一个RSS种子时，它可以发送一条消息。或者由背景页面发送一条消息，要求content script修改一个网页的内容。</p>

<p><img src="http://img.qihoo.com/images/2008/360chrome/img/open/content1.gif" alt="" /></p>

<p>剩下的就不详细解释了，对于刚刚做第一个插件的人来说了解到这里就足够了，有兴趣的可以翻看上文连接的文档。</p>

<p>然后可以为自己的插件设计一个icon，一般icon要比19x19大，于是我趁机自学了一会儿ps，话说mac上的ps确实比较好用。我选了这么一个icon。</p>

<p><img src="https://lh4.googleusercontent.com/6o17ENKhCJT5YtwiaXjBvc9sHU-rP8PsMmeR6oW5Bw=s256-no" alt="" /></p>

<p>放到默认路径下，命名为icon.png，与manifest上写的一致。其实很多比较成熟的插件的icon都会放在同一的image文件夹下，并且根据像素大小区分的比较细致，在此不表。</p>

<p>然后是在默认路径下新建popup.html的页面，也就是我们希望在点击插件的时候弹出来的页面，其实就是一个html页面，如果乐意完全可以先塞一个hello world进去看看效果。如：</p>

<pre><code>&lt;html&gt;
 &lt;body&gt;
   &lt;p&gt;Hello World.&lt;/p&gt;
 &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>因为我想做的是即时比分直播的插件，但是找了下有类似的页面但是没类似的api，由于我自己web水平不高，于是想了个馊主意，去<a href="http://www.hupu.com">hupu</a>上抓取网页的一部分来动态生成我要的页面。最后我找到了hupu页面上确实有这个部分，最后我提取到这样的一个页面，指向今天的nba比赛比分简报，着实是我想要的内容。页面url是http://www.hupu.com/global/match?type=nba&amp;date=2014-03-01，最后date后的值是当日的日期，而js获取日期的函数我会，但是却遇到了一个麻烦，就是我不会写怎么从外域用js抓取某个页面中某一段的html代码再生成一个新的html页面，这也直接导致了这个插件流产。后来我调整了页面的大小，去掉了头尾不需要的部分，得到了这么一个插件效果：</p>

<p><img src="https://lh6.googleusercontent.com/-31qIooQxMyc/UxW9LN1YYuI/AAAAAAAAADw/mra9GWe_mB4/w680-h906-no/2e2eb9389b504fc2c1e9eab5e7dde71191ef6dcf.jpg" alt="" /></p>

<p>这基本也是我想要的效果，上面队名和数据、视频的超链接都能保持，可惜这是我写死的静态页面，之后就想找个靠谱的前端工程师，能帮我做成动态的。我原本以为能用正则表达式去把外域网页的html匹配下来，结果呵呵了……</p>

<p>后来在坑爹的饼师兄建议下用iframe插了个球队信息进去，摔，这完全不是我要的啊！</p>

<p><img src="https://lh6.googleusercontent.com/-0ZuUqZQERfs/UxW9LIdNQVI/AAAAAAAAAD0/CaFcSeqUv0k/w1060-h856-no/8644ebf81a4c510f05e6b8aa6259252dd42aa564.jpg" alt="" /></p>

<p>最后只要把做好的插件保存好，然后在chrome插件管理中，选中开发者模式，再载入本地插件，就能在上面查看调试了。</p>

<p>于是……今天的最大收获是复习了好一会儿js，学会了用photoshop修简单的icon，然后还把正则表达式认认真真看了一编……</p>

<p>最后附上一个不错的正则表达式入门资料，还有一些做好的简单的chrome插件源代码，等哪时候有空了再去看。这个插件的全部代码我po到自己的github上了，跪求指点交流。</p>

<ul>
<li><a href="http://open.chrome.360.cn/extension_dev/samples.html">一些插件的开发文档</a></li>
<li><a href="https://deerchao.net/tutorials/regex/regex.htm">正则表达式30分钟入门</a></li>
<li><a href="https://github.com/kakack/NBA-live-beta">NBA-live-beta on Github</a></li>
</ul>

]]></content:encoded>
    </item>
    
    <item>
      <title>云计算与海量数据处理之我见</title>
      <link href="http://kakack.github.io/2014/02/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8E%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E6%88%91%E8%A7%81/"/>
      <pubDate>2014-02-28T00:00:00+08:00</pubDate>
      <author>Kaka Chen</author>
      <guid>http://kakack.github.io/2014/02/云计算与海量数据处理之我见</guid>
      <content:encoded><![CDATA[<p><img src="http://img170.poco.cn/mypoco/myphoto/20121008/22/66065238201210082201148707562946517_002.gif" alt="" /></p>

<p>感谢<a href="http://www.qyjohn.net/?p=1552">婉君的博客</a>，让我自己也很想写篇博文来整理和罗列一下个人对于云计算和海量数据这方面的看法和理解，全部内容仅为个人理解。
另外感谢<a href="http://blog.chetui.org/">撤退学长的博客</a>，分享了很多有价值的内容。</p>

<hr />

<p><del>大清早拉肚子不睡觉真大丈夫？</del></p>

<hr />

<ul>
<li>所谓<strong>云计算</strong>什么的，其实就是自己这里搞不好的事情丢给牛逼的学长们去完成</li>
</ul>


<p><code>云计算（Cloud Computing），是一种基于互联网的计算方式，通过这种方式，共享的软硬件资源和信息可以按需求提供给计算机和其他设备。优点是自助、共享、灵活、易监测度量。主要的服务模式有软件即服务（SaaS）、平台即服务（PaaS）和基础架构即服务（IaaS）</code></p>

<p>宏观上讲，从单一的某台机器的虚拟化到实现云计算，是一个对物理资源逐步封装的过程，同时，将虚拟化资源低阶的使用权限和特定虚拟机生命周期的管理权限留给云服务的使用者，把对集成资源高阶的管理和配置配置资源留给云服务的提供者。简言之，在使用云计算服务的过程中，给用户带来的最大的体验改进就在于其不需要知道参与计算的物理设备的具体情况与其实现方法，只需要关注于自己需要这些云资源去完成的计算任务即可。</p>

<p>本科时候有个室友听说我当时在搞云计算方向，他的态度是这玩意儿太概念，太空洞，至少在那个时候还缺少一些支柱型的科学体系和实验支持。我不是很同意他的观点，但是也很难否定他。现在业界对于云计算的定义我个人觉得都显得比较复杂和纠结，往往会有种玩票的即视感，事实上自从2006年8月9日，Google首席执行官埃里克·施密特在搜索引擎大会（SES San Jose 2006）首次提出“云计算”的概念以来，云计算一直缺乏一种能让每个从业者和团队都认可的定义，原因也很简单，因为大家都将其套用到自己实际的应用和开发模式当中。举个不是很恰当的例子，比如有人在大学上课接受教育，有人在幼儿园学唱歌画画接受教育，还有人在新东方学挖掘机或者厨师接受教育，当这三个人聚在一起的时候，都觉得别人的教育方式和自己的不太一样，然后开始怀疑到底是自己的教育方式不对还是别人的不对。其实关于云计算最提纲挈领的理解可以总结为一句话：<strong><em>通过网络以自助服务的方式获得所需要的IT资源的模式。</em></strong></p>

<p>其中有三个关键点：获取路径：通过网络；获取方式：自助服务；获取对象：IT资源。</p>

<p>另外，NIST还定义了三种服务模式(SaaS\PaaS\IaaS)和四种实施模式(公有云、私有云、社区云和混合云)。</p>

<p>总而言之，我其实不是很认可把云计算归为一门独立的计算机技术，因为其技术架构其实是集成了一系列现有的技术理念和实现方法，我更认可把它归类为计算机科学和网络技术发展过程中，一个较为高层次的集成化商业模式，是在通讯和信息技术不断发展的未来中，面临个人终端计算能力瓶颈所采取的必然的解决方案。单纯从技术架构上讲，整个云计算模式可以被视作这样三横一竖的结构：</p>

<p><img src="http://infoqstatic.com/resource/articles/analyze-cloud-architecture/zh/resources/cloud_computing1.jpg" alt="" /></p>

<p>当然，我个人对这个分层方法也持保留态度，比如在显示层中，不仅仅只有web浏览器这一种反馈方式，因为对于云计算来说，广义上的B/S和C/S模式都有，所以仅有web-browser显示方式是远不够的。在现在的学术研究中，三层的重视程度是由上往下递增的，可以说对于云计算来讲，绝大多数的科研经历还是放在最底层的基础设施层，而且系统虚拟化，NoSQL以及分布式计算（含处理和存储）都会是云计算未来发展的主攻方向。</p>

<p>关于虚拟化和云计算的关系，包括其间还有一层的虚拟机监视器（VMM）之间的关系，推荐去看<a href="http://www.qyjohn.net/?p=1552">婉君的博客</a>，写的思路非常清楚，结构很整洁，我之后有空了想详细罗列一下做个阅读笔记。</p>

<p>关于NoSQL，推荐<a href="http://book.douban.com/subject/25662138/">NoSQL精粹</a>一书，寒假时候刚刚看完，入门不错，把NoSQL里几个主要概念都罗列的很清楚，以后有空也会详细做个阅读笔记。</p>

<p>最后是分布式计算和云计算的关系，这两者之前其实很微妙，很多道行不深的同学往往会把二者混为一谈，或者简单认为OpenStack那样的就是云计算，Hadoop那样的分布式计算，其实不然。对于分布式计算来说，最完整也最学术的概述应该是这样的：</p>

<p><code>分布式计算是一门计算机科学，主要研究分布式系统。一个分布式系统包括若干通过网络互联的计算机。这些计算机互相配合以完成一个共同的目标（我们将这个共同的目标称为“项目”）。具体的过程是：将需要进行大量计算的项目数据分割成小块，由多台计算机分别计算，再上传运算结果后统一合并得出数据结论。在分布式系统上运行的计算机程序称为分布式计算程序；分布式编程就是编写上述程序的过程。</code></p>

<p>简言之就是一卡车可乐我一个人搬不动，即使搬得动我也要花很久时间才能够把它们全搬完，于是我找了很多力气跟我差不多的小伙伴，每人搬一两箱，于是很快就搬完了。登登登登~这种做法很像我们算法中的分治法，将大问题化成若干个相似或者相同的子问题，还可以然后递归分化，直到分到的子问题足够小能够直接解决，最后把各个子问题的结果汇总合并，得到大问题的计算结果。也有人认为分布式运算是一种特殊形式的并行计算方法，简单说来，如果处理单元共享内存，就称为并行计算，反之就是分布式计算。</p>

<p>所以云计算和分布式计算二者的区别还是比较明显的，北航的钱德沛教授有过比较，在此我总结一下：</p>

<ol>
<li>虚拟化：分布式计算主旨是聚合分布资源，支持虚拟组织，提供高层次的服务。而云计算的资源相对集中，主要以数据中心的形式，通过网络提供底层资源的使用，并不强调虚拟组织（VO）的概念。</li>
<li>资源使用的初衷：分布式计算是针对单点高性能资源不够用所以要继承多处资源，任何节点既可以使用别的节点的资源，也必须贡献出自己资源；而云计算更具有普适性，对资源数量和质量要求更低，可以有自己的专属资源，更不要求贡献自己本机的资源。</li>
<li>异构性：在对待异构性方面，二者理念上有所不同。分布式计算用中间件屏蔽异构系统，力图使用户面向同样的环境，把困难留在中间件，让中间件完成任务。而云计算实际上承认异构，用镜像执行，或者提供服务的机制来解决异构性的问题。当然不同的云计算系统还不太一样，像Google一般用比较专用的自己的内部的平台来支持。</li>
<li>任务形式：分布式计算用执行作业形式使用，在一个阶段内完成作用产生数据。而云计算支持持久服务，用户可以利用云计算作为其部分IT基础设施，实现业务的托管和外包。</li>
<li>用途：分布式计算更偏向于科研方向，云计算一开始出来就是明确的企业用途，而且商业模型清晰。</li>
</ol>


<hr />

<ul>
<li>所谓<strong>大数据</strong>什么的，不是说你把几GB或者几TB或者几PB的数据往那一丢随便做点处理就可以了的！</li>
</ul>


<p>首先我想说的是，之所以把大数据和云计算这两个词放在一起说，不仅因为这两个词在当今不管你是不是搞计算机科学的听到都会觉得挺热门，更重要的一点是，这两个词经常被误用和曲解。云计算的误用多存在于将一些传统的B/S、C/S服务或者一些简单的Internet服务都被称为是云计算，但大数据的误用可着实是多了去了。对大数据的误读主要有以下几种情况：一种是数据不够大，比如我见过某地政府自称使用大数据技术分析了某几个月群众关于其工作的电邮反馈，得出了人民群众最关心的政府热点是神马云云，然后我发现他们一个月连email带短信，撑死不会超过一万条反馈记录，虽然到底多大的数据量才能够得上“大数据”还没有非常明确的界定，但这么点数据压力显然不够，至于微博上其他一些打着“大数据”旗号搞得常规化“样本统计”就更多了，如果一定要从规模上做界定的话，截止2012年，单一数据集至少在TB以上才能够得上所谓的“大数据”。第二种是数据集足够大，但没有后续了，这也是比较尴尬的一点，因为所谓的“大数据”技术其实是一种非常宽泛的称呼，其中不仅包括对于大量数据的存储，更包括了对这样大量数据的前期收集，中期过滤、分析、管理、操作，以及短期或长期的储存。甚至可以说，到目前为止，储存和一些相对基础的计算早已不是大数据发展的瓶颈了。早期的各类OLAP工具已经足够给力了，后来类似海杜普这样的东西彻底降低了分布式数据的架构成本和门槛，就彻底将大数据带入了一个普及的领域。现在真正的瓶颈实际上是在于前端的数据收集过程和之后的商业模型建立以及后续使用方法。所以我们常说，<strong>数据本身是没有任何价值的，价值是通过对数据的合理使用得到的。</strong>跟传统的数据分析、数理统计相比，大数据处理往往没有特定的方向和标准，需要数据不断建立新的模型，再不断调整处理算法，而传统的统计往往会有具体的方向，甚至会得出一个特定的、真实的结论。举个例子，<del>数字是我瞎编的</del>，淘宝网上一年卖出了很多很多bra（数据量够大了吧！），然后我们算出来平均每个女性淘宝用户一年要买5个bra，<del>小伙伴们撕的真勤快</del>，其中，又数东北爷们撕的最勤快，一年撕4.5个，西藏朋友比较厚道，一年撕2.5个，然后浙江姑娘喜欢在夏天买bra，而冬天绝大多数的bra都被广东和海南两地的姑娘买走了等等……这些都是属于传统的数理统计就可以解决的问题，包括对之后的一些预测或者分类，如我们知道有个姑娘size是C，喜欢在年初买好一整年的bra，平均每年是4.1个，那么我们也能通过传统数理统计和模式识别来进行预测这个姑娘可能是哪个地方的。所以传统数理统计都基于这种粗颗粒度的特征，又可以用传统的计算方法和模型较为直接得得到结论。但如果是要去探讨一个在工作压力下会选择男性化生活方式的姑娘是否会因为某品牌的电视广告来改变她的bra购买习惯，或者要去探讨一个是由于传统伦理作用而对同性恋持反对态度的姑娘是否会在某一段恋爱结束后突然对bra的购买能力增强，这就可以勉强视作一种大数据计算和处理的思想。所以说大数据的计算方法，更着重于一些细颗粒度的特征值（无法直接从数据中观察得到，属于数据间相对深层次的潜在联系，更多的是指在某一信息或者条件作用下主体的反应等），同时具有较高的直接或间接的使用价值，比如让淘宝多为工作压力大上班族女性用户推荐某特定品牌bra，或者为情绪波动大的女性用户在某一个流行韩剧结束后推荐同款bra等能更好地引诱其购买。</p>

<p>从理论上来讲，最早定义大数据这个概念的IBM将大数据的特征归纳为4个“V”（量Volume，多样Variety，价值Value，速Velocity），或者说特点有四个层面：第一，数据体量巨大，当时认为至少要PB起步；第二，数据类型繁多，比如，网络日志、视频、图片、地理位置信息等等。第三，价值密度低，商业价值高。第四，处理速度快。入门性读物<a href="http://book.douban.com/subject/20429677/">大数据时代</a>提到大数据带来的三大数据处理的改变：<strong><em>“不要随机样本，而是全体数据”、“不是精确性，而是混杂性”、“不是因果关系，而是相关关系”</em></strong>，但是我个人对其持保留意见，因为大数据并非简单的用普查代替抽样，否定精确性又只关注相关关系。</p>

<p>最后，从大数据的价值链条来分析，存在三种模式：</p>

<p>　　1. 手握大数据，但是没有利用好；比较典型的是金融机构，电信行业，政府机构等。</p>

<p>　　2. 没有数据，但是知道如何帮助有数据的人利用它；比较典型的是IT咨询和服务企业，比如，埃森哲，IBM，Oracle等。</p>

<p>　　3. 既有数据，又有大数据思维；比较典型的是Google，Amazon，Mastercard等。</p>

<hr />

<p>先就写到这里，断断续续写了两天，之后有想到什么新的再往上加吧。</p>

<p>贴几个国内关于大数据和云计算的资讯</p>

<ul>
<li><p><a href="http://www.csdn.net/tag/%E5%A4%A7%E6%95%B0%E6%8D%AE/slideshare">csdn大数据讲义</a></p></li>
<li><p><a href="http://www.thebigdata.cn/###">中国大数据</a></p></li>
<li><p><a href="http://www.chinacloud.cn/">中国云计算</a></p></li>
<li><p><a href="https://cloud.google.com/">google cloud</a></p></li>
<li><p><a href="http://www.tbdata.org/">阿里数据平台</a></p></li>
</ul>

]]></content:encoded>
    </item>
    
    <item>
      <title>Pages_on_github（mac）</title>
      <link href="http://kakack.github.io/2014/02/pages_on_github%EF%BC%88mac%EF%BC%89/"/>
      <pubDate>2014-02-26T00:00:00+08:00</pubDate>
      <author>Kaka Chen</author>
      <guid>http://kakack.github.io/2014/02/pages_on_github（mac）</guid>
      <content:encoded><![CDATA[<p><img src="http://ww3.sinaimg.cn/mw690/b03122c9gw1dy8p12igokg.gif" alt="" /></p>

<p>一直打算在github上搞个博客，一直由于懒惰没能成行<br>
做本科毕设的时候虽然有接触过一点web前端的内容，但都是很皮毛的html+css+js，要说自己从零开始写个好看点的page出来真不容易，此外md语言之前也没怎么多写，作为逼格直线上升的同学，<em>letax</em>和<em>md</em>简直就是必修课，不然还怎么愉快地嘲笑那些用<strong>Word</strong>和<strong>txt</strong>的小伙伴们233333</p>

<hr />

<p><del>其实写这第一篇blog的目的是想来用新玩具个hello world我会随便说？</del></br></p>

<hr />

<p>既然写了就稍微说几句在Git上搭建Pages的办法，不然Blog没营养没人看啊摔！( ิ◕㉨◕ ิ)<br><br>
我自己是看<a href="http://yanping.me/cn/blog/2012/03/18/github-pages-step-by-step/">这个蜀黍的blog</a>搞的，写的挺完整但是还是有点高估了同学们的智商，吾就将其说的搞的简单明了一丢丢。</p>

<p>首先，每个教程都会逼格很高地介绍一下<strong><em>git+github+markdown+jekyll</em></strong>的好处，总的来说是git完成备份，md完成排版，jekyll完成网站那么简单，所以整个环境无非就是需要这三样东西。</p>

<p>Git：你需要一个git的账号，一个git的空间，然后再一个git的资源叫<em>username</em>.github.io，其中<em>username</em>是自己的用户名，比如我的就是kakack，github会提供一些template供用户自动生成页面，可以先选一个试试看，资源建立后十几分钟能方位https://<em>username</em>.github.com。然后再git clone到本地，就可以在本地进行编辑了。</p>

<p>Jekyll：在终端可以自行下载<code>sudo gem install jekyll</code></p>

<p>接下去就去选一个靠谱的框架玩，一般推荐去Octopress和Jekyll Bootstrap，另外<a href="https://github.com/mojombo/jekyll/wiki/sites">github</a>上也有一些推荐的。至于Octopress和Jekyll哪个好，可以看<a href="http://www.zhihu.com/question/19996679">知乎上</a>的比较。</p>

<p>最后只要把下载下来的template覆盖掉自己本地的文件，然后再在资源路径下</p>

<p><code>git add -A .</code>全选所有文件</p>

<p><code>git commit -am "message"</code></p>

<p><code>git push</code></p>

<p>就能把现有的template全部po到<em>username</em>.github.io上</p>

<p>之后的事情就是把别人template上的内容改成自己的内容即可，有些非git上的page还得把人家的CNAME文件删除。</p>

<p>最后就可以写一篇这样的hello world 软文，放在_post文件夹下，愉快地玩耍了。</p>

<hr />

<p>最后补一些有用的参考资源：</p>

<hr />

<ul>
<li><p><a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html">入门指南</a></p></li>
<li><p><a href="http://wowubuntu.com/markdown/">markdown简易语法</a></p></li>
</ul>

]]></content:encoded>
    </item>
    
  </channel>
</rss>
